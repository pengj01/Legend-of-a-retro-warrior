import pygame
import math
import random
import sys

"""
Legend of a Retro Warrior — single-file (piercing + wider hits)
Boss spawns 3 holes at once (telegraphed), 2s display -> holes; and rooms can randomly be "hole rooms."
Holes now deal 1 damage on contact (not instant kill).
Optional decorative barrels (fallback images included).

NEW:
- Simple Skill Tree (press T to open; 1–5 to buy). Gain +1 skill point every 3 rooms (1,4,7,...).
- Per-room blessing: 50% chance to heal +1 HP on entry; "Aegis" skill auto-restores shield each room.

Controls: WASD move • Space attack • 1–4 weapon • E open door • T skill menu • P pause • H help • R restart
"""

# ------------------------------
# helpers
# ------------------------------

def try_load_image(path, size=None, fallback_size=(48, 48), fallback_color=(200, 50, 200)):
    try:
        surf = pygame.image.load(path).convert_alpha()
        if size:
            surf = pygame.transform.smoothscale(surf, size)
        return surf
    except Exception:
        surf = pygame.Surface(size or fallback_size, pygame.SRCALPHA)
        surf.fill(fallback_color)
        pygame.draw.rect(surf, (255, 255, 255), surf.get_rect(), 2)
        return surf


def try_load_sound(path):
    try:
        return pygame.mixer.Sound(path)
    except Exception:
        class _Silent:
            def play(self, *args, **kwargs): pass
        return _Silent()

# ------------------------------
# init
# ------------------------------

pygame.init()
try:
    pygame.mixer.init()
except Exception:
    pass

SCREEN_WIDTH, SCREEN_HEIGHT = 1000, 800
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Legend of a Retro Warrior")
clock = pygame.time.Clock()
FPS = 60

font_small = pygame.font.SysFont(None, 22)
font = pygame.font.SysFont(None, 30)
font_big = pygame.font.SysFont(None, 56)

# ------------------------------
# assets (fallback-friendly)
# ------------------------------

player_up_img    = try_load_image("playerupdefalt.jpg",  (48, 48), fallback_color=(220,220,255))
player_down_img  = try_load_image("playerdowndefalt.png",(48, 48), fallback_color=(220,220,255))
player_left_img  = try_load_image("playerleftdefalt.png",(48, 48), fallback_color=(220,220,255))
player_right_img = try_load_image("playerightdefalt.png",(48, 48), fallback_color=(220,220,255))

wooden_sword_img = try_load_image("woodensword.png", (40, 40), fallback_color=(160,120,60))
katana_img       = try_load_image("katana.png",      (40, 40), fallback_color=(200,200,200))
greatsword_img   = try_load_image("greatsword.png",  (50,120), fallback_color=(180,180,220))
bow_img          = try_load_image("bow.png",         (40, 40), fallback_color=(160,100,60))
arrow_img        = try_load_image("arrow.png",       (8,  32), fallback_color=(230,230,230))

shield_img  = try_load_image("shield.png",  (64, 64), fallback_color=(120,200,255))
warning_img = try_load_image("warning.png", (120,120), fallback_color=(255,200,50))
hole_img    = try_load_image("hole.png",    (150,150), fallback_color=(50,50,50))
bed_img     = try_load_image("bed.png",     (200,100), fallback_color=(180,60,60))
boss_img    = try_load_image("boss.png",    (200,200), fallback_color=(255,60,150))

# Decorative fallbacks so Barrel never NameErrors
barrel1_img = try_load_image("barrel1.png", (56, 64), fallback_color=(120,80,40))
barrel2_img = try_load_image("barrel2.png", (56, 64), fallback_color=(100,60,30))
dirt1       = try_load_image("dirt.png",    (56, 56), fallback_color=(90,70,50))

try:
    pygame.mixer.music.load("level_music.wav")
    pygame.mixer.music.play(-1)
except Exception:
    pass
zombie_hit_sound = try_load_sound("zombie_hit.wav")
slash_sound      = try_load_sound("slash_sound.wav")

shooter_cube_img= pygame.Surface((30,30)); shooter_cube_img.fill((255,200,0))
blue_cube_img   = pygame.Surface((30,30)); blue_cube_img.fill((0,120,255))
green_cube_img  = pygame.Surface((30,30)); green_cube_img.fill((0,200,100))
red_cube_img    = pygame.Surface((30,30)); red_cube_img.fill((220,60,60))
purple_cube_img = pygame.Surface((30,30)); purple_cube_img.fill((160,60,200))

# ---- Dark Room / Fog-of-War settings (put near other globals) ----
DARK_ROOM = False
DARK_ROOM_CHANCE = 0.25    # % of rooms that are dark
BASE_DARK_ALPHA = 240       # overlay opacity (0..255)
PLAYER_LIGHT_RADIUS = 115   # player vision radius
ENEMY_LIGHT_RADIUS  = 80    # small halos on enemies
DOOR_LIGHT_RADIUS   = 120   # glow on the exit

# ------------------------------
# entities
# ------------------------------

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.dir_img = player_down_img
        self.rect = self.dir_img.get_rect(center=(x, y))
        self.speed = 5.2
        self.vel = pygame.Vector2()
        self.last_attack = 0
        self.weapon = "wooden"
        self.hp = 5
        self.max_hp = 5
        self.shield_intact = True
        self.i_frames = 0.0
        # Skill-derived modifiers
        self.damage_bonus = 0
        self.cooldown_mult = 1.0

    def cooldown(self):
        base = {"wooden":600, "katana":250, "big":700, "bow":350}[self.weapon]
        return int(base * self.cooldown_mult)

    def move(self, keys):
        d = pygame.Vector2(keys[pygame.K_d]-keys[pygame.K_a], keys[pygame.K_s]-keys[pygame.K_w])
        if d.length_squared(): d = d.normalize()
        self.vel = d * self.speed
        self.rect.centerx = max(24, min(SCREEN_WIDTH-24, self.rect.centerx + self.vel.x))
        self.rect.centery = max(24, min(SCREEN_HEIGHT-24, self.rect.centery + self.vel.y))
        if abs(d.x) > abs(d.y):
            self.dir_img = player_right_img if d.x > 0 else player_left_img
        elif d.y != 0:
            self.dir_img = player_down_img if d.y > 0 else player_up_img

    def handle_input(self):
        keys = pygame.key.get_pressed()
        self.move(keys)
        now = pygame.time.get_ticks()
        if keys[pygame.K_SPACE] and now - self.last_attack > self.cooldown():
            self.attack(); self.last_attack = now; slash_sound.play()
        if keys[pygame.K_1]: self.weapon = "wooden"
        if keys[pygame.K_2]: self.weapon = "katana"
        if keys[pygame.K_3]: self.weapon = "big"
        if keys[pygame.K_4]: self.weapon = "bow"

    def draw(self, surf):
        img = self.dir_img.copy()
        if self.i_frames > 0 and (pygame.time.get_ticks()//60)%2==0:
            img.set_alpha(120)
        surf.blit(img, img.get_rect(center=self.rect.center))

    def attack(self):
        cx, cy = self.rect.center
        if self.weapon == "bow":
            attacks.add(Arrow(cx, cy, self.dir_img, damage=15 + self.damage_bonus))
        elif self.weapon == "katana":
            attacks.add(Slash(cx, cy, self.dir_img, speed=22, range_px=130, color=(220,220,255), thickness=8,  damage=16 + self.damage_bonus))
        elif self.weapon == "big":
            attacks.add(Slash(cx, cy, self.dir_img, speed=12, range_px=150, color=(255,210,150), thickness=12, damage=30 + self.damage_bonus))
        else:
            attacks.add(Slash(cx, cy, self.dir_img, speed=16, range_px=120, color=(255,120,120), thickness=8,  damage=12 + self.damage_bonus))

    def damage(self, amt, knockback=None):
        if self.i_frames > 0: return
        if self.shield_intact:
            self.shield_intact = False
            self.i_frames = 0.8
            return
        self.hp -= amt
        self.i_frames = 1.0
        if knockback is not None:
            self.rect.centerx = int(max(24, min(SCREEN_WIDTH-24, self.rect.centerx + knockback.x)))
            self.rect.centery = int(max(24, min(SCREEN_HEIGHT-24, self.rect.centery + knockback.y)))

class Slash(pygame.sprite.Sprite):
    def __init__(self, x, y, dir_img, speed=16, range_px=120, color=(255,120,120), thickness=8, damage=12):
        super().__init__()
        self.speed = speed
        self.range = range_px
        self.dist = 0
        self.damage = damage
        self.color = color
        self.thickness = thickness
        if dir_img == player_up_img: self.angle = -math.pi/2
        elif dir_img == player_down_img: self.angle = math.pi/2
        elif dir_img == player_left_img: self.angle = math.pi
        else: self.angle = 0
        self.pos = pygame.Vector2(x, y)
        self.image = pygame.Surface((1,1), pygame.SRCALPHA)
        self.rect = pygame.Rect(x-6, y-6, 12, 12)
        self.hit_inflate = 18
    def update(self):
        dx = math.cos(self.angle)*self.speed; dy = math.sin(self.angle)*self.speed
        self.pos.x += dx; self.pos.y += dy
        self.rect.center = (int(self.pos.x), int(self.pos.y))
        self.dist += self.speed
        if self.dist >= self.range: self.kill()
    def draw(self, surf):
        end = (int(self.pos.x), int(self.pos.y))
        start = (int(self.pos.x - math.cos(self.angle)*12), int(self.pos.y - math.sin(self.angle)*12))
        pygame.draw.line(surf, self.color, start, end, self.thickness)

class Arrow(pygame.sprite.Sprite):
    def __init__(self, x, y, dir_img, damage=15):
        super().__init__()
        # Rotate by multiples of 90°, then apply uniform scale only (no warp)
        if dir_img == player_up_img:
            self.angle = -math.pi/2
            img = pygame.transform.rotate(arrow_img, 180)
        elif dir_img == player_down_img:
            self.angle = math.pi/2
            img = pygame.transform.rotate(arrow_img,   0)
        elif dir_img == player_left_img:
            self.angle = math.pi
            img = pygame.transform.rotate(arrow_img, 270)
        else:  # right
            self.angle = 0
            img = pygame.transform.rotate(arrow_img,  90)
        scale = 1.15
        w, h = img.get_size()
        img = pygame.transform.smoothscale(img, (int(w*scale), int(h*scale)))
        self.image = img
        self.pos = pygame.Vector2(x, y)
        self.speed = 24
        self.rect = self.image.get_rect(center=(x, y))
        self.damage = damage
        self.range = 380
        self.dist = 0
        self.hit_inflate = 12
    def update(self):
        dx = math.cos(self.angle) * self.speed
        dy = math.sin(self.angle) * self.speed
        self.pos.x += dx; self.pos.y += dy
        self.rect.center = (int(self.pos.x), int(self.pos.y))
        self.dist += self.speed
        if self.dist >= self.range: self.kill()

class Cube(pygame.sprite.Sprite):
    def __init__(self, img, x, y, hp=1, speed=(2.5, 3.5)):
        super().__init__()
        self.image = img
        self.rect = self.image.get_rect(center=(x, y))
        self.max_hp = hp; self.hp = hp
        self.speed = random.uniform(*speed)
    def update(self, target_pos):
        d = pygame.Vector2(target_pos) - self.rect.center
        if d.length_squared(): d = d.normalize()
        self.rect.centerx += d.x * self.speed
        self.rect.centery += d.y * self.speed
    def draw_bar(self, surf, color_func):
        r = max(0, self.hp) / max(1, self.max_hp)
        w = int(30 * r)
        pygame.draw.rect(surf, color_func(r), (self.rect.x-15, self.rect.y-18, w, 5))

class BlueCube(Cube):
    def __init__(self, x, y): super().__init__(blue_cube_img, x, y, hp=1,   speed=(2.4,3.4))
class GreenCube(Cube):
    def __init__(self, x, y): super().__init__(green_cube_img, x, y, hp=50,  speed=(3.0,4.0))
    def draw(self, surf): self.draw_bar(surf, lambda r: (0,255,0) if r>0.5 else (255,0,0))
class RedCube(Cube):
    def __init__(self, x, y): super().__init__(red_cube_img,   x, y, hp=160, speed=(3.2,4.6))
    def draw(self, surf):
        def c(r): return (0,255,0) if r>0.6 else (255,255,0) if r>0.3 else (255,165,0) if r>0.1 else (255,0,0)
        self.draw_bar(surf, c)
class PurpleCube(Cube):
    def __init__(self, x, y): super().__init__(purple_cube_img,x, y, hp=60,  speed=(4.0,4.7))
    def draw(self, surf):
        def c(r): return (0,255,0) if r>0.6 else (255,255,0) if r>0.3 else (255,165,0) if r>0.1 else (255,0,0)
        self.draw_bar(surf, c)

class YellowDoor(pygame.sprite.Sprite):
    def __init__(self, side):
        super().__init__()
        self.side = side
        if side in ("top", "bottom"):
            self.image = pygame.Surface((SCREEN_WIDTH//4, 10))
            self.rect  = self.image.get_rect(midtop=(SCREEN_WIDTH//2, 0)) if side=="top" else self.image.get_rect(midbottom=(SCREEN_WIDTH//2, SCREEN_HEIGHT))
        else:
            self.image = pygame.Surface((10, SCREEN_HEIGHT//4))
            self.rect  = self.image.get_rect(midleft=(0, SCREEN_HEIGHT//2)) if side=="left" else self.image.get_rect(midright=(SCREEN_WIDTH, SCREEN_HEIGHT//2))
        self.image.fill((255,255,0))
        self.opened = False

class Boss(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = boss_img
        self.rect = self.image.get_rect(center=(x, y))
        self.max_health = 3000
        self.health = self.max_health
        self.base_speed = 2.2
        self.hole_cd = 6000  # ms
        self.last_hole = 0
        self.hole_duration = 600
        # multiple telegraphs
        self.telegraphs = []  # list of {"rect": Rect, "time": int}

    def update(self, player_pos):
        speed = self.base_speed + (1 - self.health / self.max_health) * 1.6
        d = pygame.Vector2(player_pos) - self.rect.center
        if d.length_squared(): d = d.normalize()
        self.rect.centerx += d.x * speed
        self.rect.centery += d.y * speed

        # spawn 3 telegraphs every cooldown
        now = pygame.time.get_ticks()
        if now - self.last_hole > self.hole_cd:
            for _ in range(3):
                x = random.randint(100, SCREEN_WIDTH - 100)
                y = random.randint(100, SCREEN_HEIGHT - 100)
                self.telegraphs.append({
                    "rect": pygame.Rect(x - 75, y - 75, 150, 150),
                    "time": now,
                })
            self.last_hole = now

    def draw(self, surf):
        # boss sprite
        surf.blit(self.image, self.image.get_rect(center=self.rect.center))
        # health bar
        ratio = self.health / self.max_health
        bw = 160
        bar = pygame.Rect(self.rect.centerx - bw // 2, self.rect.top - 18, int(bw * ratio), 10)
        pygame.draw.rect(surf, (50, 50, 50), (bar.x, bar.y, bw, 10))
        col = (0, 255, 0) if ratio > 0.6 else (255, 255, 0) if ratio > 0.3 else (255, 120, 0) if ratio > 0.1 else (255, 0, 0)
        pygame.draw.rect(surf, col, bar)
        # telegraphs / holes
        now = pygame.time.get_ticks()
        for tg in self.telegraphs:
            t = now - tg["time"]
            if t < self.hole_duration:
                r = int(75 + 20 * (1 - t / self.hole_duration))
                pygame.draw.circle(surf, (255, 200, 50), tg["rect"].center, r, 4)
                surf.blit(warning_img, warning_img.get_rect(center=tg["rect"].center))
            else:
                surf.blit(hole_img, tg["rect"])
class EnemyBullet(pygame.sprite.Sprite):
    def __init__(self, x, y, target_pos, speed=8, damage=1, lifetime=2500):
        super().__init__()
        self.image = pygame.Surface((10,10), pygame.SRCALPHA)
        pygame.draw.circle(self.image, (255,180,70), (5,5), 5)
        self.rect = self.image.get_rect(center=(x, y))
        v = pygame.Vector2(target_pos) - pygame.Vector2(x, y)
        self.vel = v.normalize() * speed if v.length_squared() else pygame.Vector2(0,0)
        self.damage = damage
        self.spawn_time = pygame.time.get_ticks()
        self.lifetime = lifetime
    def update(self):
        self.rect.centerx += int(self.vel.x)
        self.rect.centery += int(self.vel.y)
        if (self.rect.right < -20 or self.rect.left > SCREEN_WIDTH+20 or
            self.rect.bottom < -20 or self.rect.top > SCREEN_HEIGHT+20 or
            pygame.time.get_ticks() - self.spawn_time > self.lifetime):
            self.kill()

class ShooterCube(Cube):
    def __init__(self, x, y):
        super().__init__(shooter_cube_img, x, y, hp=1, speed=(2.4, 3.1))
        self.min_range = 180
        self.max_range = 420
        self.last_shot = 0
        self.shoot_cd_ms = random.randint(1700, 2300)
        self.burst_chance = 0.25
        self.speed -=1.5
    def update(self, target_pos):
        to_player = pygame.Vector2(target_pos) - pygame.Vector2(self.rect.center)
        if to_player.length_squared() == 0:
            return
        dist = to_player.length()
        dir_vec = to_player.normalize()
        if dist < self.min_range:
            move = -dir_vec * self.speed
        elif dist > self.max_range:
            move = dir_vec * self.speed
        else:
            perp = pygame.Vector2(-dir_vec.y, dir_vec.x) * random.uniform(-1, 1) * 0.6
            move = perp
        self.rect.centerx = int(self.rect.centerx + move.x)
        self.rect.centery = int(self.rect.centery + move.y)
        now = pygame.time.get_ticks()
        if now - self.last_shot >= self.shoot_cd_ms:
            enemy_projectiles.add(EnemyBullet(self.rect.centerx, self.rect.centery, target_pos))
            self.last_shot = now
            if random.random() < self.burst_chance:
                enemy_projectiles.add(EnemyBullet(self.rect.centerx, self.rect.centery, target_pos))

# Decorative Barrels
class Barrel(pygame.sprite.Sprite):
    def __init__(self, x, y, variant=1):
        super().__init__()
        if variant==1:
            self.image = barrel1_img
        elif variant==2:
            self.image = barrel2_img
        else:
            self.image = dirt1
        self.rect = self.image.get_rect(center=(x, y))

# ------------------------------
# game globals & helpers
# ------------------------------

all_sprites = pygame.sprite.Group()
attacks = pygame.sprite.Group()
cubes = pygame.sprite.Group()
barrels = pygame.sprite.Group()  # decorations
enemy_projectiles = pygame.sprite.Group()

player = Player(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)
all_sprites.add(player)

door = None; doorcount = 0
boss_spawned = False; boss_defeated = False; boss = None
show_help = True

# Hole room state
HOLE_ROOM = False
current_holes = []  # list of pygame.Rect
HOLE_ROOM_CHANCE = 0.25  # 25% to become a hole room (tweak!)

STATE_TITLE, STATE_PLAY, STATE_PAUSE, STATE_GAMEOVER = 0,1,2,3
state = STATE_TITLE

# ==== Skill tree / room blessing state ====
skill_points = 0
skill_menu_open = False
room_message = ""
room_message_timer = 0.0

# skill data: id -> dict(name, lvl, max, cost)
skills = {
    "maxhp":   {"name": "Heartsmith (+1 Max HP)",      "lvl": 0, "max": 5, "cost": 1},
    "damage":  {"name": "Sharper Blades (+3 dmg)",      "lvl": 0, "max": 5, "cost": 1},
    "speed":   {"name": "Boots of Haste (+6% speed)",   "lvl": 0, "max": 5, "cost": 1},
    "cooldown":{"name": "Quick Hands (-6% CD)",         "lvl": 0, "max": 5, "cost": 1},
    "shield":  {"name": "Aegis (sheild 100% chance auto-restore on room)", "lvl": 0, "max": 1, "cost": 2},
}

def skill_effects_apply_to_player():
    """Recompute derived stats from skills."""
    player.max_hp = 5 + skills["maxhp"]["lvl"]
    player.hp = min(player.hp, player.max_hp)
    speed_mult = 1.0 + 0.06 * skills["speed"]["lvl"]
    player.speed = 5.2 * speed_mult

    player.damage_bonus = 3 * skills["damage"]["lvl"]
    player.cooldown_mult = 1.0 - 0.06 * skills["cooldown"]["lvl"]
def grant_skill_point_if_needed():
    """+1 skill point every 3 rooms: 1,4,7,10,..."""
    global skill_points
    if doorcount == 1 or ((doorcount - 1) % 3 == 0 and doorcount > 1):
        skill_points += 1

def set_room_message(text, seconds=2.0):
    global room_message, room_message_timer
    room_message = text
    room_message_timer = seconds

def apply_room_blessing():
    healed = False
    if random.random() < 0.3 and player.hp < player.max_hp:
        player.hp += 1
        healed = True

    if skills["shield"]["lvl"] > 0:
        player.shield_intact = True

    msgs = []
    if healed: msgs.append("+1 HP")
    if skills["shield"]["lvl"] > 0: msgs.append("Shield Restored")
    if msgs:
        set_room_message("Room Blessing: " + ", ".join(msgs), 2.2)
    else:
        set_room_message("Room Blessing: (no effect)", 1.6)

def draw_skill_menu(surf):
    panel = pygame.Rect(SCREEN_WIDTH//2 - 320, SCREEN_HEIGHT//2 - 180, 640, 360)
    pygame.draw.rect(surf, (25,25,32), panel, border_radius=10)
    pygame.draw.rect(surf, (90,90,110), panel, width=2, border_radius=10)

    title = font_big.render("Skill Tree", True, (255,255,255))
    surf.blit(title, title.get_rect(midtop=(panel.centerx, panel.top + 16)))

    pts = font.render(f"Skill Points: {skill_points}", True, (220,220,255))
    surf.blit(pts, (panel.left + 20, panel.top + 70))

    y = panel.top + 120
    ids = list(skills.keys())
    for i, sid in enumerate(ids, start=1):
        s = skills[sid]
        line = f"{i}. {s['name']}  [Lv {s['lvl']}/{s['max']}]  Cost:{s['cost']}"
        surf.blit(font.render(line, True, (235,235,235)), (panel.left + 24, y))
        y += 38

    hint = font_small.render("Press number (1-5) to buy • T to close", True, (200,200,200))
    surf.blit(hint, hint.get_rect(midbottom=(panel.centerx, panel.bottom - 12)))

def safe_random_pos(min_dist=180):
    for _ in range(300):
        x = random.randint(40, SCREEN_HEIGHT-40); y = random.randint(40, SCREEN_HEIGHT-40)
        if pygame.Vector2(x, y).distance_to(player.rect.center) >= min_dist:
            return x, y
    return(0,0)
# ---- Darkness / Fog-of-war drawing (put with helper functions) ----
def draw_darkness(surface):
    if not DARK_ROOM:
        return
    overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, BASE_DARK_ALPHA))

    # Player light
    pygame.draw.circle(overlay, (0, 0, 0, 0), player.rect.center, PLAYER_LIGHT_RADIUS)

    # Door light

    # Enemy halos

    # Boss telegraphs/holes glow a bit
    if boss_spawned and boss:
        now = pygame.time.get_ticks()
        for tg in getattr(boss, "telegraphs", []):
            t = now - tg["time"]
            rad = 70 if t < boss.hole_duration else 90
            pygame.draw.circle(overlay, (0, 0, 0, 0), tg["rect"].center, rad)

    surface.blit(overlay, (0, 0))

def spawn_room():
    """Rebuilds the room, with optional enemies and (new) hole rooms and barrels."""
    global door, cubes, boss_spawned, boss, HOLE_ROOM, current_holes
    all_sprites.empty(); attacks.empty(); cubes.empty(); barrels.empty(); all_sprites.add(player)

    # Door
    side = random.choice(["top","bottom","left","right"]) if doorcount not in (10,) else "right"
    door = YellowDoor(side); all_sprites.add(door)

    # Keep boss if present
    if boss_spawned and boss:
        all_sprites.add(boss)

    # Hole room roll — not on rest room (10) or big wave (20)
    HOLE_ROOM = False
    current_holes = []
    if doorcount not in (10, 20) and random.random() < HOLE_ROOM_CHANCE:
        HOLE_ROOM = True
        n = min(12, 3 + doorcount // 5)
        for _ in range(n):
            x, y = safe_random_pos(140)
            current_holes.append(pygame.Rect(x - 75, y - 75, 150, 150))

    # Decorative barrels (optional)
    # if not HOLE_ROOM and random.random() < 0.6:
    #     for _ in range(random.randint(1, 3)):
    #         bx, by = safe_random_pos(0)
    #         variant = random.randint(1,3)
    #         b = Barrel(bx, by, variant)
    #         barrels.add(b)
    #         all_sprites.add(b)

    # Special rest room
    if doorcount == 10:
        return
    # ---- Roll a dark room inside spawn_room() (add after HOLE_ROOM logic) ----
    global DARK_ROOM
    if doorcount not in (10, 20):   # skip rest/big-wave if you want
        DARK_ROOM = (random.random() < DARK_ROOM_CHANCE)
    else:
        DARK_ROOM = False

    # Big mixed wave
    if doorcount == 20 and not boss_defeated:
        pack = []
        for _ in range(8):  pack.append(BlueCube(*safe_random_pos(200)))
        for _ in range(6):  pack.append(GreenCube(*safe_random_pos(260)))
        for _ in range(6):  pack.append(RedCube(*safe_random_pos(260)))
        for _ in range(6):  pack.append(PurpleCube(*safe_random_pos(260)))
        for e in pack:
            cubes.add(e); all_sprites.add(e)
        return

    # Regular spawns (still happen even if it's a hole room)
    base = 2 + doorcount//5
    for _ in range(base):
        b = BlueCube(*safe_random_pos(180)); cubes.add(b); all_sprites.add(b)
    if doorcount > 5:
        for _ in range(random.randint(0, 1 + doorcount//10)):
            g = GreenCube(*safe_random_pos(220)); cubes.add(g); all_sprites.add(g)
    if doorcount > 8 and random.random() < 0.5:
        for _ in range(random.randint(0, 1 + doorcount//15)):
            r = RedCube(*safe_random_pos(240)); cubes.add(r); all_sprites.add(r)
    if doorcount > 12 and random.random() < 0.6:
        for _ in range(random.randint(0, 1 + doorcount//12)):
            p = PurpleCube(*safe_random_pos(240)); cubes.add(p); all_sprites.add(p)
    if doorcount > 12:
        for _ in range(random.randint(1, 1 + doorcount//25)):
            s = ShooterCube(*safe_random_pos(220))
            cubes.add(s); all_sprites.add(s)
def open_door_if_clear(keys):
    if door and not door.opened and player.rect.colliderect(door.rect) and keys[pygame.K_e]:
        door.opened = True

def go_through_door_if_touching():
    global doorcount, boss_spawned, boss
    if door and door.opened and player.rect.colliderect(door.rect):
        if len(cubes) == 0:
            if boss_defeated or not(boss_spawned):
                doorcount += 30
                player.rect.center = (SCREEN_WIDTH//2, SCREEN_HEIGHT//2)
                if doorcount == 10:
                    player.hp = min(player.max_hp, player.hp+2); player.shield_intact = True
                if doorcount == 21:
                    player.hp = min(player.max_hp, player.hp+2); player.shield_intact = True
                # decide boss spawn after rebuild
                spawn_boss_now = (doorcount == 30 and not boss_spawned and not boss_defeated)
                spawn_room()
                # apply skills & blessing each new room
                skill_effects_apply_to_player()
                grant_skill_point_if_needed()
                apply_room_blessing()
                if spawn_boss_now:
                    boss = Boss(200, 200)
                    boss_spawned = True
                    all_sprites.add(boss)

# first room
spawn_room()
skill_effects_apply_to_player()
apply_room_blessing()

# ------------------------------
# UI helpers
# ------------------------------

def draw_hearts(surf, x, y, hp, max_hp):
    for i in range(max_hp):
        col = (255,80,80) if i < hp else (90,90,90)
        pygame.draw.rect(surf, col, (x + i*18, y, 14, 14), border_radius=3)

def draw_help_panel(surf):
    if not show_help: return
    lines = [
        "WASD move, Space attack, 1-4 weapon",
        "E open door, P pause, H help, T skill tree",
    ]
    for i, line in enumerate(lines):
        surf.blit(font_small.render(line, True, (220,220,220)), (20, SCREEN_HEIGHT - 60 + i*18))

def draw_weapon_corner(surf):
    img = {"wooden":wooden_sword_img, "katana":katana_img, "big":greatsword_img, "bow":bow_img}[player.weapon]
    badge = pygame.transform.smoothscale(img, (60,60)) if player.weapon != "big" else pygame.transform.smoothscale(img, (40,90))
    pad = 16; rect = badge.get_rect(topright=(SCREEN_WIDTH - pad, pad))
    pygame.draw.rect(surf, (30,30,35), rect.inflate(14,14), border_radius=8)
    pygame.draw.rect(surf, (80,80,90), rect.inflate(14,14), width=2, border_radius=8)
    surf.blit(badge, rect)

# ------------------------------
# main loop
# ------------------------------

running = True
STATE_TITLE, STATE_PLAY, STATE_PAUSE, STATE_GAMEOVER = 0,1,2,3
state = STATE_TITLE

while running:
    dt = clock.tick(FPS) / 1000.0
    for event in pygame.event.get():
        if event.type == pygame.QUIT: running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE: running = False
            if state == STATE_TITLE and event.key in (pygame.K_RETURN, pygame.K_SPACE): state = STATE_PLAY
            elif state == STATE_GAMEOVER and event.key == pygame.K_r:
                player.rect.center = (SCREEN_WIDTH//2, SCREEN_HEIGHT//2)
                player.hp = player.max_hp; player.shield_intact = True; player.i_frames = 0
                doorcount = 0; boss_spawned = False; boss = None
                skill_points = 0
                for k in skills: skills[k]["lvl"] = 0
                spawn_room(); state = STATE_PLAY
                skill_effects_apply_to_player()
                apply_room_blessing()
            elif state == STATE_PLAY:
                if event.key == pygame.K_p: state = STATE_PAUSE
                if event.key == pygame.K_h: show_help = not show_help
                if event.key == pygame.K_t: skill_menu_open = not skill_menu_open
                # purchase skills (1-5) while menu open
                if skill_menu_open and event.unicode in ("1","2","3","4","5"):
                    idx = int(event.unicode) - 1
                    ids = list(skills.keys())
                    if 0 <= idx < len(ids):
                        sid = ids[idx]
                        s = skills[sid]
                        if s["lvl"] < s["max"] and skill_points >= s["cost"]:
                            s["lvl"] += 1
                            skill_points -= s["cost"]
                            old_hp = player.hp
                            skill_effects_apply_to_player()
                            if player.hp > old_hp:
                                set_room_message("Max HP up!", 1.4)


            elif state == STATE_PAUSE and event.key == pygame.K_p:
                state = STATE_PLAY

    keys = pygame.key.get_pressed()

    if state == STATE_PLAY:
        # update on-screen message timer
        if room_message_timer > 0:
            room_message_timer = max(0.0, room_message_timer - dt)

        if skill_menu_open:
            # Freeze combat while the menu is open (still draw world/UI below)
            player.i_frames = max(0.0, player.i_frames - dt)
        else:
            player.handle_input(); player.i_frames = max(0.0, player.i_frames - dt)
            for e in list(cubes): e.update(player.rect.center)

            # Boss logic
            if boss_spawned and boss:
                boss.update(player.rect.center)
                # damage from any active boss hole (permanently active after it appears)
                for tg in getattr(boss, 'telegraphs', []):
                    t = pygame.time.get_ticks() - tg['time']
                    if t >= boss.hole_duration:  # hole is now active and stays active
                        if player.rect.colliderect(tg['rect']):
                            player.damage(1)
                            if player.hp <= 0:
                                state = STATE_GAMEOVER
                if boss.rect.colliderect(player.rect):
                    k = pygame.Vector2(player.rect.center) - boss.rect.center
                    if k.length_squared(): k.scale_to_length(24)
                    player.damage(1, knockback=k)
                    if player.hp <= 0: state = STATE_GAMEOVER

            for a in list(attacks): a.update()

            # piercing collisions (no a.kill() on hit)
            for a in list(attacks):
                hit_rect = a.rect.inflate(getattr(a, 'hit_inflate', 0), getattr(a, 'hit_inflate', 0))
                for e in [e for e in cubes if hit_rect.colliderect(e.rect)]:
                    e.hp -= getattr(a, 'damage', 12); zombie_hit_sound.play()
                    if e.hp <= 0: e.kill()
                if boss_spawned and boss and hit_rect.colliderect(boss.rect):
                    boss.health -= getattr(a, 'damage', 12)
                    if boss.health <= 0:
                        boss.kill(); boss_spawned = False

            for e in list(cubes):
                if e.rect.colliderect(player.rect):
                    k = pygame.Vector2(player.rect.center) - e.rect.center
                    if k.length_squared(): k.scale_to_length(24)
                    player.damage(1, knockback=k)
                    if player.hp <= 0: state = STATE_GAMEOVER
            for b in list(enemy_projectiles):
                b.update()
                if b.rect.colliderect(player.rect):
                    player.damage(getattr(b, "damage", 1))
                    b.kill()
                    if player.hp <= 0:
                        state = STATE_GAMEOVER
            # Hole room collision — deal 1 damage instead of instant death
            if HOLE_ROOM:
                for r in current_holes:
                    if player.rect.colliderect(r):
                        player.damage(1)
                        if player.hp <= 0:
                            state = STATE_GAMEOVER
                        break

            open_door_if_clear(keys)
            if door and door.opened and player.rect.colliderect(door.rect): go_through_door_if_touching()

    # draw
    screen.fill((50,50,55))
    if state == STATE_TITLE:
        t = font_big.render("Legend of a Retro Warrior", True, (255,255,255))
        screen.blit(t, t.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 - 40)))
        s = font.render("Press Enter to start", True, (220,220,220))
        screen.blit(s, s.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 20)))
    else:
        world = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)

        # Rest room visuals
        if doorcount == 10:
            world.blit(bed_img, (200, 300)); world.blit(bed_img, (600, 600))
            world.blit(bed_img, (200, 600)); world.blit(bed_img, (600, 300))
            msg = font.render("Rest and recover... prepare yourself", True, (200,80,80))
            world.blit(msg, msg.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//3)))

        # Hole room visuals
        if HOLE_ROOM:
            for r in current_holes:
                world.blit(hole_img, r)

        # Barrels first (decor)
        for b in barrels:
            world.blit(b.image, b.rect)

        # Enemies
        for e in cubes:
            world.blit(e.image, e.image.get_rect(center=e.rect.center))
            if isinstance(e, (GreenCube, RedCube, PurpleCube)): e.draw(world)
        for b in enemy_projectiles:
            world.blit(b.image, b.rect)
        # Boss
        if boss_spawned and boss:
            boss.draw(world)

        # Attacks
        for a in attacks:
            if isinstance(a, Slash): a.draw(world)
            else: world.blit(a.image, a.rect)

        # Player & door
        player.draw(world)
        if door: world.blit(door.image, door.rect)

        screen.blit(world, (0,0))
        draw_darkness(screen)
        # UI
        draw_hearts(screen, 20, 20, player.hp, player.max_hp)
        img = {"wooden":wooden_sword_img, "katana":katana_img, "big":greatsword_img, "bow":bow_img}[player.weapon]
        badge = pygame.transform.smoothscale(img, (60,60)) if player.weapon != "big" else pygame.transform.smoothscale(img, (40,90))
        pad = 16; rect = badge.get_rect(topright=(SCREEN_WIDTH - pad, pad))
        pygame.draw.rect(screen, (30,30,35), rect.inflate(14,14), border_radius=8)
        pygame.draw.rect(screen, (80,80,90), rect.inflate(14,14), width=2, border_radius=8)
        screen.blit(badge, rect)
        if player.shield_intact:
            screen.blit(shield_img, shield_img.get_rect(bottomright=(SCREEN_WIDTH-20, SCREEN_HEIGHT-20)))
        room_txt = font.render(f"Room: {doorcount}", True, (255,255,255))
        screen.blit(room_txt, (SCREEN_WIDTH//2 - room_txt.get_width()//2, 14))

        # Room blessing message (top-center)
        if room_message_timer > 0 and room_message:
            msgsurf = font.render(room_message, True, (230, 230, 120))
            screen.blit(msgsurf, msgsurf.get_rect(midtop=(SCREEN_WIDTH//2, 48)))

        draw_help_panel(screen)

        # Pause/Game over overlays
        if state == STATE_PAUSE:
            p = font_big.render("PAUSED", True, (255,255,255))
            screen.blit(p, p.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
        if state == STATE_GAMEOVER:
            g = font_big.render("YOU DIED", True, (255,80,80))
            screen.blit(g, g.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 - 10)))
            s = font.render(f"Room Score: {doorcount}  —  Press R to Restart", True, (230,230,230))
            screen.blit(s, s.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 40)))

        # Skill menu overlay (draw last)
        if skill_menu_open:
            draw_skill_menu(screen)

    pygame.display.flip()

pygame.quit()
sys.exit()
